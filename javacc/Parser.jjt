options
{
    LOOKAHEAD = 1;
    MULTI = true;
}

PARSER_BEGIN(Parser)

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
	" " | "\r" | "\t" | "\n"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN:
{
    <IMPORT: "import">
    | <STATIC: "static">
    | <DOT: ".">
    | <STAR: "*">
    | <SEMICOLON: ";">
    | <COMMA: ",">
    | <CLASS: "class">
    | <EXTENDS: "extends">
    | <LBRACE: "{">
    | <RBRACE: "}">
    | <PUBLIC: "public">
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <RETURN: "return">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRINGARR: "String[]">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <ASSIGN: "=">
    | <LBRACKET: "[">
    | <RBRACKET: "]">
    | <SC_AND: "&&">
    | <LESS: "<">
    | <PLUS: "+">
    | <MINUS: "-">
    | <SLASH: "/">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <BANG: "!">
    | <LENGTH: "length">
    | <IDENTIFIER: ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])* >
    | <NUMERIC: (["0"-"9"])+ >
}

SimpleNode Program() : {}
{
    ( ImportDeclaration() )* ClassDeclaration() <EOF> {return jjtThis;}
}


void ImportDeclaration() : {}
{
    <IMPORT> Name() <SEMICOLON>
}

/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
void Name() : {Token t;}
{
    t = <IDENTIFIER> {jjtThis.value = t.image;} (LOOKAHEAD(2) <DOT> t = <IDENTIFIER> {jjtThis.value = t.image;} )*
}

void ClassDeclaration() : {Token t;}
{
    <CLASS>
    t=<IDENTIFIER> {jjtThis.value = t.image;}
    (<EXTENDS> t=<IDENTIFIER> {jjtThis.value = t.image;})?
    <LBRACE>
    (VarDeclaration() <SEMICOLON>)*
    (MethodDeclaration())*
    <RBRACE>
}

void VarDeclaration() : {}
{
    Type() Identifier()
}

void MethodDeclaration() : {Token t;}
{
    <PUBLIC>
    (
        Type()
        t=<IDENTIFIER> {jjtThis.value = t.image;}
        <LPAREN>
        (
            VarDeclaration()
            (
                <COMMA> VarDeclaration()
            )*
        )?
        <RPAREN>
        <LBRACE>
        MethodDeclarationBody()
        <RETURN> Expression() <SEMICOLON>
        <RBRACE>
    |
         <STATIC>
         <VOID>
         <MAIN>
         <LPAREN>
         t=<STRINGARR> {jjtThis.value = t.image;}
         Identifier()
         <RPAREN>
         <LBRACE>
         MethodDeclarationBody()
         <RBRACE>
    )
}

void MethodDeclarationBody() : {Token t;}
{
    (PrimitiveType() Identifier() <SEMICOLON>) MethodDeclarationBody()
    |
        t = <IDENTIFIER> { jjtThis.value = t.image; } AfterIdentifier() <SEMICOLON> (Statement())* // {statement} no enunciado
    |
        NoIdentifierStatement() (Statement())*
    |
        {}
}

void Identifier() : { Token t; }
{
    t = <IDENTIFIER> {jjtThis.value = t.image;}
}

void Type() : {Token t;}
{
    t = <IDENTIFIER> {jjtThis.value = t.image;}
    |
    PrimitiveType() // "int", "[", "]", "boolean", "int"
}

void PrimitiveType() : {Token t; Boolean b = false;}
{
    t = <BOOLEAN> {jjtThis.value = t.image;}
    |
    (
        t = <INT> (<LBRACKET> <RBRACKET> {b = true;})? {
            if(b)
                jjtThis.value = t.image + "[]"; // int[]
            else
                jjtThis.value = t.image; // int
        }
    )
}

void Statement() : {}
{
    NoIdentifierStatement()
    |
    IdentifierStatement()
}

void IdentifierStatement() : {} // Identifier, "=", Expression, ";" | Identifier, "[", Expression, "]", "=", Expression, ";" | Expression, ";"
{
    Identifier() AfterIdentifier() <SEMICOLON>
}

void AfterIdentifier() : {}
{
    <ASSIGN> Expression()
    |
    InsideArray() <ASSIGN> Expression() <SEMICOLON>
    |
    ExpNotArray()
}

void InsideArray() : {}
{
    <LBRACKET> Expression() <RBRACKET>
}

void NoIdentifierStatement() : {} // "{", { Statement }, "}" | "if", "(", Expression, ")", Statement, "else", Statement | "while", "(", Expression, ")", Statement
{
    <LBRACE> (Statement())* <RBRACE>
    |
    IfStatement()
    |
    WhileStatement()
    //|
    //ExpressionNotID() <SEMICOLON>  ambiguo?
}

void IfStatement() : {}
{
    <IF> IfWhileCondition() Statement()
    <ELSE> Statement()
}

void WhileStatement() : {}
{
    <WHILE> IfWhileCondition() Statement()
}

void IfWhileCondition() : {}
{
    <LPAREN> Expression() <RPAREN>
}

void Expression() : {}
{
    Expr1() ExprAnd()
}

void ExprAnd() : {}
{
    <SC_AND> Expr1() ExprAnd()
    |
    {}
}

void Expr1() : {}
{
    Expr2() ExprLess()
}

void ExprLess() : {}
{
    <LESS> Expr2() ExprLess()
    |
    {}
}

void Expr2() : {}
{
    Expr3() ExprSumSub()
}

void ExprSumSub() : {}
{
    <MINUS> Expr3() ExprSumSub()
    |
    <PLUS> Expr3() ExprSumSub()
    |
    {}
}

void Expr3() : {}
{
     Expr4() ExprMulDiv()
}

void ExprMulDiv() : {}
{
    <STAR> Expr4() ExprMulDiv()
    |
    <SLASH> Expr4() ExprMulDiv()
    |
    {}
}

void Expr4() : {}
{
    Expr5() ExprDot()
}

void ExprDot() : {}
{
    <DOT> AfterDot() ExprArray() ExprDot()
    |
    {}
}

void AfterDot() : {Token t;}
{
    t=<LENGTH> {jjtThis.value = t.image;}
    |
    t=<IDENTIFIER> {jjtThis.value = t.image;}
    <LPAREN>
    (Expression() (<COMMA> Expression())*)?
    <RPAREN>
}

void Expr5() : {}
{
    ExprLiteral() ExprArray()
}

void ExprArray() : {}
{
    InsideArray() ExprArray()
    |
    {}
}

void ExprLiteral() : {}
{
    NoIdentifierExprLiteral()
    |
    Identifier()
}

void NoIdentifierExprLiteral() : {Token t;}
{
    t=<TRUE> {jjtThis.value = t.image;}
    |
    t=<FALSE> {jjtThis.value = t.image;}
    |
    <THIS>
    |
    <BANG> (Expr5() ExprDot())
    |
    <NUMERIC>
    |
    <NEW>
    (
        t=<INT> InsideArray() {jjtThis.value = t.image + "[]";}
        |
        t = <IDENTIFIER> <LPAREN> ((Expression() (<COMMA> Expression())*)? {jjtThis.value = t.image;}) <RPAREN>
    )
    |
    <LPAREN> Expression() <RPAREN>
}

void ExpNotArray() #void : {}
{
    Exp1NotArray() ExprAnd()
}

void Exp1NotArray() #void : {}
{
    Exp2NotArray() ExprLess()
}

void Exp2NotArray() #void : {}
{
    Exp3NotArray() ExprSumSub()
}

void Exp3NotArray() #void : {}
{
    ExprDot() ExprMulDiv()
}

/*

JAVACODE
void recover_while_error() {
    ParseException e = generateParseException();
    System.out.println(e.toString());
    Token t;

    //skip tokens until first parenthesis is reacherd
    do {
        t = getNextToken();
    } while (t.kind != ParenthesisEnd);

    //skip extra parenthesis
    while (getToken(1).kind == ParenthesisEnd) {
        t = getNextToken();
    }
}

*/


/*
JAVACODE void error_skipto(int kind) #SyntaticError
{
  Json.syntaticError = true;
  ParseException e = generateParseException()
; // generate the exception object.
System.out.println("Error found at column "+ e.currentToken.beginColumn+ " line "+ e.currentToken.beginLine);
Token t;
do
{
  t = getNextToken();
  if (t.kind == CBRA) return;
}

while (t.kind != kind);
}*/
